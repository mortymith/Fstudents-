// =============================================
// CORE USER AND AUTHENTICATION TABLES
// =============================================
  Table users {
    id int [pk, increment]
    email varchar(255) [not null, unique]
    password_hash varchar(255) [not null]
    full_name varchar(255) [not null]
    role enum('admin', 'inventory_manager', 'viewer') [not null]
    is_active boolean [default: true]
    last_login_at timestamp
    created_at timestamp [default: `now()`]
    updated_at timestamp [default: `now()`]

    // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Unique constraint for authentication
    email [unique]
    
    // Role-based access control queries
    role [name: 'idx_user_role']
    
    // Active user filtering (highly selective)
    (is_active) [name: 'idx_active_users']
    
    // User search and management
    (full_name) [name: 'idx_full_name']
    
    // Composite indexes for common admin queries
    (role, is_active) [name: 'idx_role_active_status']
    (is_active, last_login_at) [name: 'idx_active_recent_login']
    
    // Login activity and monitoring
    (last_login_at) [name: 'idx_last_login']
    
    // Date-based user analytics
    (created_at) [name: 'idx_created_at']
    (updated_at) [name: 'idx_updated_at']
    
    // User onboarding and activation tracking
    (created_at, is_active) [name: 'idx_user_onboarding']
    
    // Administrative reporting composites
    (role, created_at) [name: 'idx_role_growth_trends']
    (is_active, role, last_login_at) [name: 'idx_user_engagement']
  }

  note: '''
  USER MANAGEMENT:
  - Core user authentication and profile data
  - Role-based access control (RBAC) for system permissions
  - Soft delete via is_active flag
  - Tracks authentication patterns via last_login_at
  '''
}

Table password_reset_tokens {
  id int [pk, increment]
  user_id int [not null]
  reset_token varchar(255) [not null, unique] // Cryptographically secure random string
  token_expires timestamp [not null] // Typically 1 hour from creation
  is_used boolean [default: false] // Prevents token reuse
  created_at timestamp [default: `now()`]
  used_at timestamp // When token was successfully consumed

  indexes {
    (reset_token) [name: 'idx_reset_tokens_token'] // Fast token validation
    (token_expires) [name: 'idx_reset_tokens_expiry'] // For cleanup of expired tokens
    (user_id, is_used) [name: 'idx_reset_tokens_user_status'] // Check for active tokens per user
  }

  note: '''
  PASSWORD RESET WORKFLOW:
  1. User requests reset → generate unique token with 1-hour expiration
  2. System emails reset link with token
  3. User clicks link → validate token exists, not expired, and not used
  4. User sets new password → mark token as used, record timestamp
  5. Token automatically expires after 1 hour for security
  
  SECURITY FEATURES:
  - Single-use tokens only
  - Short expiration window
  - Cryptographically secure tokens
  - Clear audit trail of reset attempts
  '''
}

Table user_sessions {
  id int [pk, increment] // Primary key
  user_id int [not null] // Foreign key to users table
  session_token varchar(255) [not null, unique] // Unique session identifier
  expires_at timestamp [not null] // Session expiration (NF-SEC-003)
  
  // SECURITY AUDITING IMPROVEMENTS
  ip_address varchar(45) [not null] // Client IP address (IPv4: 15 chars, IPv6: 45 chars)
  user_agent text [not null] // Browser/device identification string
  
  // SESSION USAGE TRACKING
  last_activity_at timestamp [not null, default: `now()`] // Last user interaction timestamp
  
  created_at timestamp [default: `now()`] // Session creation time

  indexes {
    (user_id) [name: 'idx_sessions_user_id'] // Fast user session lookup
    (expires_at) [name: 'idx_sessions_expiry'] // Efficient session cleanup
    (last_activity_at) [name: 'idx_sessions_activity'] // Active session queries
    (ip_address) [name: 'idx_sessions_ip'] // Security investigation
    (session_token) [name: 'idx_sessions_token'] // Fast token validation (unique)
  }

  note: '''
  SECURITY AND USAGE TRACKING FEATURES:
  
  IP ADDRESS TRACKING:
  - Stores client IP for security monitoring and geo-location
  - Helps detect suspicious login patterns (multiple locations)
  - IPv6 support with 45-character limit
  
  USER AGENT TRACKING:
  - Records browser, OS, and device information
  - Helps identify session hijacking attempts
  - Useful for support and analytics
  
  LAST ACTIVITY TRACKING:
  - Enforces accurate session timeout (NF-SEC-003)
  - Identifies abandoned sessions for cleanup
  - Provides user engagement metrics
  
  SESSION MANAGEMENT:
  - Update last_activity_at on every authenticated request
  - Automatic cleanup of expired sessions via scheduled job
  - Real-time session monitoring for security teams
  '''
}

// =============================================
// CORE BUSINESS ENTITY TABLES
// =============================================

Table categories {
  id int [pk, increment] // Primary key
  name varchar(255) [not null, unique] // Unique category name (FR-CAT-001)
  description text // Optional category description
  
  // HIERARCHICAL CATEGORIES IMPROVEMENT
  parent_id int [null] // Self-referencing foreign key for nested categories
  
  is_active boolean [default: true] // Soft delete for category archiving
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  indexes {
    (name) [name: 'idx_categories_name']
    (parent_id) [name: 'idx_categories_parent'] // Fast child category lookups
    (is_active) [name: 'idx_categories_active'] // Active category filtering
  }
}

Table suppliers {
  id int [pk, increment] // Primary key
  name varchar(255) [not null] // Supplier company name (FR-SUP-001)
  contact_person_name varchar(255) // Primary contact person
  contact_email varchar(255) // Contact email address
  contact_phone varchar(50) // Contact phone number
  address_line1 varchar(255) // Street address line 1
  address_line2 varchar(255) // Street address line 2
  city varchar(100) // City
  state varchar(100) // State/Province
  postal_code varchar(20) // Postal/ZIP code
  country varchar(100) // Country
  is_active boolean [default: true] // Archive instead of delete (FR-SUP-003)
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  indexes {
    // Primary key index (auto-created by most databases)
    (id) [pk]

    // Business key index for unique supplier identification
    (name) [name: 'idx_suppliers_name']

    // Contact information indexes for quick lookups
    (contact_email) [name: 'idx_suppliers_email']
    (contact_phone) [name: 'idx_suppliers_phone']
    
    // Geographic indexes for regional reporting and filtering
    (country) [name: 'idx_suppliers_country']
    (state, city) [name: 'idx_suppliers_state_city']
    (city) [name: 'idx_suppliers_city']
    (postal_code) [name: 'idx_suppliers_postal']
    
    // Status and activity filtering
    (is_active) [name: 'idx_suppliers_active']
    
    // Composite index for common search patterns
    (is_active, country, state) [name: 'idx_suppliers_active_region']
    
    // Temporal indexes for reporting and cleanup
    (created_at) [name: 'idx_suppliers_created']
    (updated_at) [name: 'idx_suppliers_updated']
  }

  note: '''
  INDEX STRATEGY RATIONALE:
  
  SEARCH PATTERNS COVERED:
  1. Lookup by supplier name (common operation)
  2. Contact searches by email or phone
  3. Regional filtering by country, state, city
  4. Active/inactive supplier filtering
  5. Temporal reporting by creation/update dates
  6. Combined status and geographic queries
  
  PERFORMANCE CONSIDERATIONS:
  - Single-column indexes support flexible WHERE clauses
  - Composite indexes optimize common query combinations
  - Geographic indexes enable regional supplier analysis
  - Status indexes support active/inactive filtering
  
  MAINTENANCE:
  - Monitor index usage and remove unused indexes
  - Consider partial indexes for large datasets
  - Regular index maintenance for optimal performance
  '''
}

Table products {
  id int [pk, increment] // Primary key
  sku varchar(100) [not null, unique] // Stock Keeping Unit - unique identifier (FR-PROD-001)
  name varchar(255) [not null] // Product name
  description text // Product description
  category_id int [not null] // Foreign key to categories
  supplier_id int [not null] // Foreign key to suppliers
  
  // PRICING AND COSTING
  price decimal(10,2) [not null] // Selling price
  cost_price decimal(10,2) // Purchase cost for margin calculations
  
  // INVENTORY MANAGEMENT ENHANCEMENTS
  low_stock_threshold int [default: 10] // Alert threshold for low stock (FR-RPT-001)
  reorder_point int [default: 15] // Automatic PO generation threshold
  reorder_quantity int [default: 50] // Default quantity to reorder

  // PERISHABLE GOODS SUPPORT
  expiry_date date // For perishable goods management
  
  // MEDIA AND IDENTIFICATION
  barcode_data varchar(255) // Barcode data for scanning (FR-CODE-001)
  qr_code_data text // QR code data for mobile scanning
  
  // STATUS AND AUDITING
  is_active boolean [default: true] // Archive products with history (FR-PROD-004)
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  indexes {
    // Primary key and unique constraints
    (id) [pk]
    (sku) [unique, name: 'idx_products_sku']
    
    // Search and filtering indexes
    (name) [name: 'idx_products_name']
    (category_id) [name: 'idx_products_category']
    (supplier_id) [name: 'idx_products_supplier']
    (is_active) [name: 'idx_products_active']
    
    // Inventory management indexes
    (low_stock_threshold) [name: 'idx_products_low_stock']
    (reorder_point) [name: 'idx_products_reorder']
    
    // Pricing and reporting indexes
    (price) [name: 'idx_products_price']
    (cost_price) [name: 'idx_products_cost']
    
    // Perishable goods management
    (expiry_date) [name: 'idx_products_expiry']
    
    // Barcode scanning optimization
    (barcode_data) [name: 'idx_products_barcode']
    
    // Composite indexes for common query patterns
    (is_active, category_id) [name: 'idx_products_active_category']
    (is_active, supplier_id) [name: 'idx_products_active_supplier']
    (category_id, price) [name: 'idx_products_category_price']
    (is_active, low_stock_threshold) [name: 'idx_products_active_low_stock']
    
    // Temporal indexes
    (created_at) [name: 'idx_products_created']
    (updated_at) [name: 'idx_products_updated']
    
    // Full-text search (implementation varies)
    // (name, description) [type: fulltext, name: 'idx_products_ft_search']
  }
}

// =============================================
// INVENTORY TRACKING TABLES
// =============================================

Table product_inventory {
  id int [pk, increment] // Primary key
  product_id int [not null, unique] // One-to-one with products
  quantity_on_hand int [not null, default: 0] // Physical inventory count
  quantity_committed int [default: 0] // Reserved for orders/sales
  quantity_available int [not null, default: 0] // Denormalized: on_hand - committed
  last_restocked_at timestamp // Last restock date for reporting
  last_counted_at timestamp // Last physical count date for accuracy tracking
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Unique constraint for one-to-one relationship
    product_id [unique]
    
    // Performance indexes for common queries
    (quantity_available) [name: 'idx_available_quantity']
    (quantity_on_hand) [name: 'idx_on_hand_quantity']
    (last_restocked_at) [name: 'idx_restock_date']
    (last_counted_at) [name: 'idx_count_date']
    
    // Composite indexes for reporting and analytics
    (quantity_available, last_restocked_at) [name: 'idx_available_restocked']
    (quantity_on_hand, last_counted_at) [name: 'idx_on_hand_counted']
    
    // Index for low stock alerts
    (quantity_available, product_id) [name: 'idx_low_stock_check']
    
    // Index for inventory aging analysis
    (last_restocked_at, quantity_on_hand) [name: 'idx_inventory_aging']
  }
}

Table purchase_orders {
  id int [pk, increment] // Primary key
  po_number varchar(100) [not null, unique] // Human-readable PO number
  supplier_id int [not null] // Foreign key to suppliers
  status enum('draft', 'ordered', 'received', 'cancelled') [default: 'draft'] // PO lifecycle
  total_amount decimal(10,2) // Calculated total for the PO
  ordered_date timestamp // Date when PO was sent to supplier
  expected_delivery_date timestamp // Estimated delivery date
  received_date timestamp // Actual receipt date
  created_by int [not null] // User who created the PO
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Unique constraint for PO number
    po_number [unique]
    
    // Foreign key indexes for joins
    supplier_id [name: 'idx_supplier_id']
    created_by [name: 'idx_created_by']
    
    // Status-based queries (high cardinality)
    status [name: 'idx_po_status']
    
    // Date-based indexes for reporting
    (ordered_date) [name: 'idx_ordered_date']
    (expected_delivery_date) [name: 'idx_expected_delivery']
    (received_date) [name: 'idx_received_date']
    (created_at) [name: 'idx_created_at']
    
    // Composite indexes for common business queries
    (status, expected_delivery_date) [name: 'idx_status_delivery']
    (supplier_id, status) [name: 'idx_supplier_status']
    (status, ordered_date) [name: 'idx_status_ordered_date']
    
    // Financial reporting indexes
    (total_amount) [name: 'idx_total_amount']
    (status, total_amount) [name: 'idx_status_amount']
    
    // Delivery monitoring index
    (expected_delivery_date, status) [name: 'idx_pending_deliveries']
    
    // Date range queries for analytics
    (ordered_date, total_amount) [name: 'idx_date_amount_analysis']
  }
}

Table purchase_order_items {
  id int [pk, increment] // Primary key
  purchase_order_id int [not null] // Foreign key to purchase_orders
  product_id int [not null] // Foreign key to products
  quantity_ordered int [not null] // Quantity ordered from supplier
  quantity_received int [default: 0] // Actual quantity received
  unit_cost decimal(10,2) [not null] // Cost per unit at time of order
  line_total decimal(10,2) [not null] // Denormalized: quantity_ordered * unit_cost
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]

  // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Foreign key indexes for joins
    purchase_order_id [name: 'idx_po_id']
    product_id [name: 'idx_product_id']
    
    // Composite foreign key indexes for efficient joins
    (purchase_order_id, product_id) [name: 'idx_po_product', unique]
    
    // Quantity-based indexes for inventory reconciliation
    (quantity_ordered) [name: 'idx_quantity_ordered']
    (quantity_received) [name: 'idx_quantity_received']
    
    // Cost analysis indexes
    (unit_cost) [name: 'idx_unit_cost']
    (line_total) [name: 'idx_line_total']
    
    // Composite indexes for common business queries
    (purchase_order_id, quantity_received) [name: 'idx_po_receipt_status']
    (product_id, unit_cost) [name: 'idx_product_pricing']
    (purchase_order_id, line_total) [name: 'idx_po_line_totals']
    
    // Receipt completion analysis
    (quantity_ordered, quantity_received) [name: 'idx_receipt_comparison']
    
    // Product purchase history
    (product_id, created_at) [name: 'idx_product_purchase_history']
    
    // Financial reporting composites
    (product_id, line_total) [name: 'idx_product_spend']
    (purchase_order_id, product_id, quantity_ordered) [name: 'idx_po_product_qty']
    
    // Partial receipt identification
    (purchase_order_id, quantity_ordered, quantity_received) [name: 'idx_partial_receipts']
  }
}

// =============================================
// STOCK MOVEMENT AND TRANSACTION TABLES
// =============================================

Table stock_movements {
  id int [pk, increment] // Primary key
  product_id int [not null] // Foreign key to products
  movement_type enum('in', 'out', 'adjustment') [not null] // Type of movement
  quantity_change int [not null] // Positive for incoming, negative for outgoing
  quantity_before int [not null] // Stock level before movement
  quantity_after int [not null] // Denormalized: before + change (for reporting)
  reference_type enum('purchase_order', 'sale', 'adjustment', 'transfer') [not null]
  reference_id int // Flexible foreign key to various transaction types
  movement_date timestamp [not null] // When the movement occurred
  created_by int [not null] // User who performed the movement
  created_at timestamp [default: `now()`]

  // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Core foreign key indexes
    product_id [name: 'idx_product_id']
    created_by [name: 'idx_created_by']
    
    // Composite product + date for stock history queries
    (product_id, movement_date) [name: 'idx_product_movement_history']
    (product_id, movement_type, movement_date) [name: 'idx_product_movement_type_history']
    
    // Movement type analysis
    movement_type [name: 'idx_movement_type']
    
    // Date-based indexes for reporting and time-series analysis
    (movement_date) [name: 'idx_movement_date']
    (created_at) [name: 'idx_created_at']
    
    // Reference tracking (polymorphic relationship)
    (reference_type, reference_id) [name: 'idx_reference_lookup']
    (reference_type, product_id) [name: 'idx_reference_product']
    
    // Stock level analysis indexes
    (quantity_after) [name: 'idx_quantity_after']
    (quantity_before) [name: 'idx_quantity_before']
    
    // Composite indexes for common audit queries
    (product_id, movement_type, quantity_change) [name: 'idx_product_movement_impact']
    (movement_date, movement_type) [name: 'idx_daily_movement_summary']
    
    // Large movement tracking
    (quantity_change) [name: 'idx_quantity_change']
    
    // User activity tracking
    (created_by, movement_date) [name: 'idx_user_activity']
    
    // Real-time stock level queries
    (product_id, movement_date, quantity_after) [name: 'idx_product_stock_timeline']
  }
}

Table stock_adjustments {
  id int [pk, increment] // Primary key
  product_id int [not null] // Foreign key to products
  adjustment_type enum('damaged', 'expired', 'returned', 'found', 'theft', 'internal_use') [not null]
  quantity_adjusted int [not null] // Typically negative, positive for 'found' items
  reason text // Detailed reason for adjustment (FR-STCK-003)
  adjustment_date timestamp [not null] // When adjustment occurred
  created_by int [not null] // User who made the adjustment
  created_at timestamp [default: `now()`]

    // Primary Index (automatically created)
  indexes {
    id [pk]
    
    // Core foreign key indexes
    product_id [name: 'idx_product_id']
    created_by [name: 'idx_created_by']
    
    // Adjustment type analysis (moderate cardinality)
    adjustment_type [name: 'idx_adjustment_type']
    
    // Date-based indexes for reporting
    (adjustment_date) [name: 'idx_adjustment_date']
    (created_at) [name: 'idx_created_at']
    
    // Quantity analysis indexes
    (quantity_adjusted) [name: 'idx_quantity_adjusted']
    
    // Composite indexes for common business queries
    (product_id, adjustment_date) [name: 'idx_product_adjustment_history']
    (adjustment_type, adjustment_date) [name: 'idx_type_adjustment_trends']
    (product_id, adjustment_type) [name: 'idx_product_adjustment_patterns']
    
    // Large adjustment tracking
    (quantity_adjusted, adjustment_date) [name: 'idx_large_adjustments']
    
    // Loss analysis (negative adjustments)
    (adjustment_type, quantity_adjusted) [name: 'idx_loss_analysis']
    
    // User accountability
    (created_by, adjustment_date) [name: 'idx_user_adjustments']
    
    // Monthly reporting composite
    (adjustment_date, adjustment_type, quantity_adjusted) [name: 'idx_monthly_adjustment_report']
    
    // Product-specific adjustment patterns
    (product_id, adjustment_type, adjustment_date) [name: 'idx_product_adjustment_analysis']
  }
}

// =============================================
// TABLE RELATIONSHIPS
// =============================================

// Password Reset Token Relationships
Ref: password_reset_tokens.user_id > users.id [delete: cascade, update: cascade]


// User Management Relationships
Ref: users.id < user_sessions.user_id

// Product Catalog Relationships
Ref: categories.id < products.category_id
Ref: suppliers.id < products.supplier_id

// Hierarchical Categories Relationship
Ref: categories.id < categories.parent_id

// Inventory Management Relationships
Ref: products.id < product_inventory.product_id
Ref: suppliers.id < purchase_orders.supplier_id
Ref: users.id < purchase_orders.created_by
Ref: purchase_orders.id < purchase_order_items.purchase_order_id
Ref: products.id < purchase_order_items.product_id

// Stock Movement Relationships
Ref: products.id < stock_movements.product_id
Ref: users.id < stock_movements.created_by
Ref: products.id < stock_adjustments.product_id
Ref: users.id < stock_adjustments.created_by